---
templateKey: post
title: 디자인 패턴
description: 싱글톤패턴, 프록시패턴 등 디자인패턴에 관해 설명하는 글입니다.
tags:
  - 디자인패턴
  - 프록시패턴
date: 2024-04-17T15:41:38.279Z
updated: 2024-04-17T15:41:38.293Z
featuredimage: https://res.cloudinary.com/dyfdioouh/image/upload/v1713266121/dog_fepvi0.jpg
---
## 싱글톤 패턴

하나의 클래스에 하나의 인스턴트는 패턴

* DB 연결 모듈에 많이 쓰임
* 하나의 인스턴스를 다른 모듈들이 공유해 비용적 장점이 있지만, 의존성이 높아진다는 단점 존재
* JS 객체를 만들면 그게 싱글톤 `const obj = { a: 13 }`
* 단위 테스트를 할 때 걸림돌이 됨. 각각의 테스트는 독립적이여야되는데 싱글톤 인스턴스를 공유하게 되므로
* 의존성 주입을 통해 결합을 느슨하게 가져갈 수 있음

```tsx
// 싱글톤을 만드는 클래스
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this
    }
    return Singleton.instance
  }
  
  getInstance() {
    return this.instance
  }
}

// 싱글톤 생성
const s1 = new Singleton()
const s2 = new Singleton()
// a === b
```

## 팩토리 패턴

상위 클래스에서 객체 생성 부분을 추상화하고 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴

* 상위 클래스에서 인스턴스 생성방식을 알 필요가 없어 유연성을 갖게됨
* 객체 생성 로직이 없어 상위 클래스에서 한부분 고치면 되므로 유지보수에 용이
  (객체 생성 로직이 있다면 다양한 케이스를 고쳐야 될것임)

```tsx
const num = new Object(42)
const str = new Object('hello')

num.constructor.name // Number
str.constructor.name // String
```

## 전략 패턴(=정책 패턴)

passport 인증 라이브러리를 예로 들 수 있는데, 인증 방식을 바꾸고 싶은 경우 같은 인터페이스로 다르게 구현된 인증 방식을 `passport.use(new LocalStrategy(...))` 혹은 `passport.use(new KakaoStrategy(...))` 와 같이 전략을 교체하여 사용할 수 있습니다.

## 옵저버 패턴

상태를 관찰하는 옵저버의 목록을 객체에 등록하여 객체에 상태변화가 있을때마다 메서드 등을 통해 객체가 직접 각 옵저버들에게 통지하는 패턴이다.

JS 프록시 객체를 통해서도 옵저버 패턴을 구현할 수 있다.

```tsx
const handler = {
  get: function(target, key) {
    return key === 'fullName' ? `${target.firstName} ${target.lastName}` : target[key]
  }
}

const proxy = new Proxy({
  firstName: 'apple',
  lastName: 'pie'
}, handler)

console.log(proxy.fullName) // 'apple pie'
```

Vue3의 `ref` 와 `reactive` 또한 JS의 `Proxy` 를 통해 구현되어있다. `Proxy` 의 두번째 매개변수인 `handler`를 통해 상태값의 변경이 이루어진다.

## 프록시 패턴과 프록시 서버

**프록시 패턴**은 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 앞단의 인터페이스 역할을 하는 디자인 패턴이다. 객체의 속성, 변환등을 보완하며 **보안, 데이터 검증, 캐싱, 로깅에 사용**되기도 하고 **프록시 서버로도 활용**된다.

* nginx도 프록시 서버로 사용된다.
* CloudFlare도 프록시 서버로 사용된다.
* CORS로 인해 개발서버에서 백엔드 API를 받아 사용할 때에도 프록시 서버를 사용한다.

## 이터레이터 패턴

이터레이터를 사용하여 이터러블한 객체의 요소들에 접근하는 디자인 패턴으로, JS를 예로 들면 `for of`를 통해 다른 자료구조이지만 `Map, Set` 의 요소들에 접근할 수 있다.

## 노출 모듈 패턴

즉시실행함수를 통해 private, public과 같은 접근 제어자를 만드는 패턴